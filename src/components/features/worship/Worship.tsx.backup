import React, { useState, useEffect, useRef } from 'react';
import { 
  calculateBaseReward, 
  getCurrentSeasonalEvent,
  getTimeOfDay,
  getRandomWeather
} from '../../../utils';
import { UserStats } from '../../../types';
import './Worship.css';
import { useAccountAbstraction } from '../../../hooks/useAccountAbstraction';
import { useGoogleMaps } from '../../../hooks/useGoogleMaps';

// å‚æ‹ç”¨ã®èª­ã¿å–ã‚Šå°‚ç”¨ç¥ç¤¾ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
const ReadOnlyShrine: React.FC = () => {
  const [shrineCanvas, setShrineCanvas] = useState<any[]>([]);

  useEffect(() => {
    // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰ç¥ç¤¾ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
    const savedCanvas = JSON.parse(localStorage.getItem('shrineCanvas') || '[]');
    setShrineCanvas(savedCanvas);
  }, []);

  const getRarityColor = (rarity: string) => {
    const colors = {
      common: '#94a3b8',
      uncommon: '#22d3ee', 
      rare: '#a855f7',
      epic: '#f59e0b',
      legendary: '#ef4444'
    };
    return colors[rarity as keyof typeof colors] || colors.common;
  };

  const getPixelData = (x: number, y: number) => {
    const pixel = shrineCanvas.find((p: any) => p.x === x && p.y === y);
    return pixel;
  };

  return (
    <div className="readonly-shrine">
      <div className="shrine-canvas-display">
        <h3>ğŸ›ï¸ ã‚ãªãŸã®ç¥ç¤¾</h3>
        <div className="pixel-canvas-readonly">
          {Array.from({ length: 12 }, (_, y) => (
            <div key={y} className="pixel-row">
              {Array.from({ length: 12 }, (_, x) => {
                const pixelData = getPixelData(x, y);
                return (
                  <div
                    key={`${x}-${y}`}
                    className="pixel readonly"
                    style={{ 
                      backgroundColor: pixelData?.color || 'rgba(255,255,255,0.1)',
                      border: pixelData ? `1px solid ${getRarityColor(pixelData.rarity || 'common')}` : '1px solid rgba(255,255,255,0.1)'
                    }}
                  >
                    {pixelData?.pixelData && (
                      <span className="pixel-emoji">{pixelData.pixelData}</span>
                    )}
                  </div>
                );
              })}
            </div>
          ))}
        </div>
        <div className="shrine-info">
          <p>ç‘æƒ³ä¸­ã€ã‚ãªãŸã®ç¥ç¤¾ãŒå¿ƒã®æ”¯ãˆã¨ãªã‚Šã¾ã™</p>
          <div className="shrine-stats">
            <span>é…ç½®æ¸ˆã¿: {shrineCanvas.length}å€‹</span>
            <span>ç¥åŠ›: {shrineCanvas.length * 10}</span>
          </div>
        </div>
      </div>
    </div>
  );
};

// Types imported from ../types

const Worship: React.FC = () => {
  // Account AbstractionçŠ¶æ…‹
  const { account, isReady, mintNFT, earnCulturalCapital } = useAccountAbstraction();

  // UIçŠ¶æ…‹
  const [isActive, setIsActive] = useState(false);
  const [selectedDuration, setSelectedDuration] = useState(300); // 5åˆ†
  const [selectedSound, setSelectedSound] = useState('bell');
  const [timeRemaining, setTimeRemaining] = useState(0);
  const [showCompletion, setShowCompletion] = useState(false);
  const [completionRewards, setCompletionRewards] = useState<any>(null);
  const [userStats, setUserStats] = useState<UserStats>({
    culturalCapital: 0,
    totalNFTs: 0,
    meditationStreak: 1,
    totalWorshipSessions: 0,
    level: 1
  });

  // ç‘æƒ³ãƒ»å‚æ‹ã‚»ãƒƒã‚·ãƒ§ãƒ³çŠ¶æ…‹
  const [breathingPhase, setBreathingPhase] = useState<'inhale' | 'hold' | 'exhale'>('inhale');
  const [breathingTimer, setBreathingTimer] = useState(4);
  const [showPrayerSelectionModal, setShowPrayerSelectionModal] = useState(false);
  const [showPrayerModal, setShowPrayerModal] = useState(false);
  
  // ç¥ˆã‚Šã®ç¨®é¡é¸æŠçŠ¶æ…‹
  const [selectedPrayerType, setSelectedPrayerType] = useState<string>('');
  const [prayerTypes] = useState([
    {
      id: 'gratitude',
      title: 'ğŸŒ¸ æ„Ÿè¬ã®ç¥ˆã‚Š',
      description: 'ä»Šæ—¥ã‚ãªãŸãŒæ„Ÿè¬ã—ã¦ã„ã‚‹ã“ã¨ã«å¿ƒã‚’å‘ã‘ã¾ã—ã‚‡ã†',
      message: 'æ·±ãæ„Ÿè¬ã®æ°—æŒã¡ã‚’è¾¼ã‚ã¦ã€3ã¤ã®æ„Ÿè¬ã‚’å¿ƒã®ä¸­ã§å”±ãˆã¾ã—ã‚‡ã†...',
      duration: 180, // 3åˆ†
      color: '#FFB7C5',
      emoji: 'ğŸŒ¸'
    },
    {
      id: 'wishes',
      title: 'ğŸ¯ é¡˜ã„ã®ç¥ˆã‚Š',
      description: 'ã‚ãªãŸã®ç›®æ¨™ã‚„é¡˜ã„ãŒå¶ã†ã‚ˆã†ç¥ˆã‚Šã¾ã—ã‚‡ã†',
      message: 'ã‚ãªãŸã®é¡˜ã„ã¨ç›®æ¨™ã«å‘ã‘ã¦ã€å¿ƒã‹ã‚‰ã®ç¥ˆã‚Šã‚’æ§ã’ã¾ã—ã‚‡ã†...',
      duration: 240, // 4åˆ†
      color: '#87CEEB',
      emoji: 'ğŸ¯'
    },
    {
      id: 'mindfulness',
      title: 'ğŸ’­ ä»Šã«é›†ä¸­ã™ã‚‹ç¥ˆã‚Š',
      description: 'ä»Šã“ã®ç¬é–“ã«æ„è­˜ã‚’å‘ã‘ã€å¿ƒã‚’è½ã¡ç€ã‹ã›ã¾ã—ã‚‡ã†',
      message: 'ä»Šã®æ„Ÿæƒ…ã‚„çŠ¶æ³ã‚’ã‚ã‚Šã®ã¾ã¾å—ã‘å…¥ã‚Œã€å¿ƒã®å¹³å®‰ã‚’ç¥ˆã‚Šã¾ã—ã‚‡ã†...',
      duration: 300, // 5åˆ†
      color: '#90EE90',
      emoji: 'ğŸ’­'
    },
    {
      id: 'peace',
      title: 'ğŸ•Šï¸ å¹³å’Œã®ç¥ˆã‚Š',
      description: 'å¿ƒã®å¹³å®‰ã¨ä¸–ç•Œã®å¹³å’Œã‚’ç¥ˆã‚Šã¾ã—ã‚‡ã†',
      message: 'å¿ƒã‹ã‚‰ã®å¹³å®‰ã¨ã€ã™ã¹ã¦ã®äººã®å¹¸ã›ã‚’ç¥ˆã‚Šã¾ã—ã‚‡ã†...',
      duration: 360, // 6åˆ†
      color: '#DDA0DD',
      emoji: 'ğŸ•Šï¸'
    },
    {
      id: 'healing',
      title: 'ğŸŒ¿ ç™’ã—ã®ç¥ˆã‚Š',
      description: 'å¿ƒèº«ã®ç™’ã—ã¨å¥åº·ã‚’ç¥ˆã‚Šã¾ã—ã‚‡ã†',
      message: 'å¿ƒã¨ä½“ã®ç™’ã—ã‚’æ±‚ã‚ã€å¥ã‚„ã‹ãªæ—¥ã€…ã‚’ç¥ˆã‚Šã¾ã—ã‚‡ã†...',
      duration: 240, // 4åˆ†
      color: '#98FB98',
      emoji: 'ğŸŒ¿'
    }
  ]);
  const [currentPrayerTimer, setCurrentPrayerTimer] = useState(0);
  const [isPrayerActive, setIsPrayerActive] = useState(false);

  // Google Mapsé–¢é€£
  const mapRef = useRef<HTMLDivElement>(null);
  const meditationTimerRef = useRef<NodeJS.Timeout | null>(null);
  const breathingTimerRef = useRef<NodeJS.Timeout | null>(null);
  const { isLoaded, error, loadGoogleMapsScript, initializeMap, addMarkers } = useGoogleMaps();

  // NFTãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½
  const dropNFTFromOmikuji = (omikujiResult: string) => {
    const dropRates = {
      'å¤§å‰': 0.8,
      'ä¸­å‰': 0.6,
      'å‰': 0.4,
      'å°å‰': 0.3,
      'æœ«å‰': 0.2,
      'å‡¶': 0.1
    };

    const dropChance = dropRates[omikujiResult as keyof typeof dropRates] || 0.1;
    const shouldDrop = Math.random() < dropChance;

    if (shouldDrop) {
      const droppedNFT = generateRandomNFT(omikujiResult);
      return droppedNFT;
    }
    return null;
  };

  // ãƒ©ãƒ³ãƒ€ãƒ NFTç”Ÿæˆ
  const generateRandomNFT = (omikujiResult: string) => {
    const nftTypes = [
      { 
        type: 'torii', 
        emoji: 'â›©ï¸', 
        name: 'é³¥å±…', 
        colors: ['#FFD700', '#DC2626', '#8B4513'],
        description: 'ç¥ç¤¾ã®å…¥ã‚Šå£ã‚’é£¾ã‚‹ç¥è–ãªé–€'
      },
      { 
        type: 'roof', 
        emoji: 'ğŸ¯', 
        name: 'å±‹æ ¹', 
        colors: ['#DC2626', '#8B4513', '#059669'],
        description: 'ä¼çµ±çš„ãªæ—¥æœ¬å»ºç¯‰ã®ç¾ã—ã„å±‹æ ¹'
      },
      { 
        type: 'pillar', 
        emoji: 'ğŸªµ', 
        name: 'æŸ±', 
        colors: ['#8B4513', '#92400E', '#451A03'],
        description: 'ç¥ç¤¾ã‚’æ”¯ãˆã‚‹é‡è¦ãªæ§‹é€ ç‰©'
      },
      { 
        type: 'decoration', 
        emoji: 'ğŸŒ¸', 
        name: 'æ¡œè£…é£¾', 
        colors: ['#FFB7C5', '#F472B6', '#EC4899'],
        description: 'å­£ç¯€ã‚’å½©ã‚‹ç¾ã—ã„è£…é£¾'
      }
    ];

    const rarityMap = {
      'å¤§å‰': 'legendary',
      'ä¸­å‰': 'epic', 
      'å‰': 'rare',
      'å°å‰': 'uncommon',
      'æœ«å‰': 'common',
      'å‡¶': 'common'
    };

    const selectedType = nftTypes[Math.floor(Math.random() * nftTypes.length)];
    const rarity = rarityMap[omikujiResult as keyof typeof rarityMap] || 'common';
    const color = selectedType.colors[Math.floor(Math.random() * selectedType.colors.length)];

    return {
      id: Date.now(),
      name: selectedType.name,
      type: selectedType.type,
      emoji: selectedType.emoji,
      rarity: rarity,
      color: color,
      power: Math.floor(Math.random() * 50) + 10,
      description: selectedType.description,
      timestamp: new Date().toISOString()
    };
  };

  // Account Abstractionã§ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒŸãƒ³ãƒˆ
  const mintRealNFT = async (nftData: any) => {
    if (!isReady || !account) return null;

    try {
      const metadata = {
        name: nftData.name,
        description: nftData.description,
        image: `data:image/svg+xml;base64,${generateSVGBase64(nftData)}`,
        attributes: [
          { trait_type: "Type", value: nftData.type },
          { trait_type: "Rarity", value: nftData.rarity },
          { trait_type: "Power", value: nftData.power },
          { trait_type: "Color", value: nftData.color },
          { trait_type: "Emoji", value: nftData.emoji }
        ]
      };

      const result = await mintNFT(
        nftData.type,
        nftData.rarity,
        nftData.power,
        metadata
      );

      return result;
    } catch (error) {
      console.error('ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ NFTãƒŸãƒ³ãƒˆã‚¨ãƒ©ãƒ¼:', error);
      return null;
    }
  };

  const generateSVGBase64 = (nftData: any): string => {
    const svg = `
      <svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
        <rect width="200" height="200" fill="${nftData.color}"/>
        <text x="100" y="120" text-anchor="middle" font-size="60" fill="white">
          ${nftData.emoji}
        </text>
        <text x="100" y="180" text-anchor="middle" font-size="16" fill="white" font-family="Arial">
          ${nftData.name}
        </text>
      </svg>
    `;
    return btoa(svg);
  };

  // ç¥ˆã‚Šã‚’æ§ã’ã‚‹ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ãŸæ™‚ã®å‡¦ç†
  const handlePrayerStart = () => {
    if (!isReady) {
      alert('ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®æº–å‚™ä¸­ã§ã™...');
      return;
    }
    setShowPrayerSelectionModal(true);
  };

  // ç¥ˆã‚Šã®ç¨®é¡ã‚’é¸æŠã—ãŸæ™‚ã®å‡¦ç†
  const handlePrayerTypeSelect = (prayerType: any) => {
    setSelectedPrayerType(prayerType.id);
    setSelectedDuration(prayerType.duration);
    setShowPrayerSelectionModal(false);
    setShowPrayerModal(true);
    setCurrentPrayerTimer(prayerType.duration);
    startSelectedPrayer(prayerType);
  };

  // é¸æŠã•ã‚ŒãŸç¥ˆã‚Šã‚’é–‹å§‹
  const startSelectedPrayer = (prayerType: any) => {
    setIsPrayerActive(true);
    setIsActive(true);
    setTimeRemaining(prayerType.duration);

    // ç¥ˆã‚Šã‚¿ã‚¤ãƒãƒ¼é–‹å§‹
    meditationTimerRef.current = setInterval(() => {
      setTimeRemaining(prev => {
        if (prev <= 1) {
          completePrayer();
          return 0;
        }
        return prev - 1;
      });
    }, 1000);

    // å‘¼å¸ã‚¬ã‚¤ãƒ‰é–‹å§‹
    startBreathingGuide();
  };

  // ç¾åœ¨ã®ç¥ˆã‚Šã‚¿ã‚¤ãƒ—ã‚’å–å¾—
  const getCurrentPrayerType = () => {
    return prayerTypes.find(type => type.id === selectedPrayerType);
  };

  // å‘¼å¸ã‚¬ã‚¤ãƒ‰
  const startBreathingGuide = () => {
    const breathingCycle = () => {
      // å¸æ°— (4ç§’)
      setBreathingPhase('inhale');
      setBreathingTimer(4);

      const inhaleTimer = setInterval(() => {
        setBreathingTimer(prev => prev - 1);
      }, 1000);

      setTimeout(() => {
        clearInterval(inhaleTimer);

        // ä¿æŒ (4ç§’)
        setBreathingPhase('hold');
        setBreathingTimer(4);

        const holdTimer = setInterval(() => {
          setBreathingTimer(prev => prev - 1);
        }, 1000);

        setTimeout(() => {
          clearInterval(holdTimer);

          // å‘¼æ°— (4ç§’)
          setBreathingPhase('exhale');
          setBreathingTimer(4);

          const exhaleTimer = setInterval(() => {
            setBreathingTimer(prev => prev - 1);
          }, 1000);

          setTimeout(() => {
            clearInterval(exhaleTimer);
          }, 4000);
        }, 4000);
      }, 4000);
    };

    breathingCycle();
    breathingTimerRef.current = setInterval(breathingCycle, 12000); // 12ç§’ã‚µã‚¤ã‚¯ãƒ«
  };

  // ç¥ˆã‚Šå®Œäº†
  const completePrayer = async () => {
    setIsActive(false);
    setIsPrayerActive(false);
    setShowPrayerModal(false);

    if (meditationTimerRef.current) {
      clearInterval(meditationTimerRef.current);
    }
    if (breathingTimerRef.current) {
      clearInterval(breathingTimerRef.current);
    }

    // å ±é…¬è¨ˆç®—
    const baseReward = calculateBaseReward(selectedDuration);
    const seasonalEvent = getCurrentSeasonalEvent();
    const weather = getRandomWeather();
    const timeOfDay = getTimeOfDay();

    const rewards = {
      culturalCapital: baseReward.culturalCapital,
      experience: baseReward.experience,
      bonus: {
        seasonal: seasonalEvent ? 20 : 0,
        weather: weather === 'sunny' ? 10 : 0,
        timeOfDay: timeOfDay === 'morning' ? 15 : 0
      }
    };

    const totalCulturalCapital = rewards.culturalCapital + 
      rewards.bonus.seasonal + 
      rewards.bonus.weather + 
      rewards.bonus.timeOfDay;

    // Account Abstractionã§æ–‡åŒ–è³‡æœ¬ç²å¾—
    if (isReady && earnCulturalCapital) {
      await earnCulturalCapital(totalCulturalCapital);
    }

    // ãŠã¿ãã˜çµæœç”Ÿæˆ
    const omikujiResults = ['å¤§å‰', 'ä¸­å‰', 'å‰', 'å°å‰', 'æœ«å‰', 'å‡¶'];
    const omikujiResult = omikujiResults[Math.floor(Math.random() * omikujiResults.length)];

    // NFTãƒ‰ãƒ­ãƒƒãƒ—åˆ¤å®š
    const droppedNFT = dropNFTFromOmikuji(omikujiResult);
    let mintResult = null;

    if (droppedNFT) {
      // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§NFTã‚’ãƒŸãƒ³ãƒˆ
      mintResult = await mintRealNFT(droppedNFT);

      // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ã‚‚ä¿å­˜
      const existingNFTs = JSON.parse(localStorage.getItem('shrineNFTs') || '[]');
      const updatedNFTs = [...existingNFTs, droppedNFT];
      localStorage.setItem('shrineNFTs', JSON.stringify(updatedNFTs));

      // ã‚«ã‚¹ã‚¿ãƒ ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ã—ã¦MyShrine ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«é€šçŸ¥
      window.dispatchEvent(new CustomEvent('newNFTDropped', { 
        detail: { nft: droppedNFT, mintResult } 
      }));
    }

    setCompletionRewards({
      ...rewards,
      totalCulturalCapital,
      omikujiResult,
      droppedNFT,
      mintResult
    });

    // çµ±è¨ˆæ›´æ–°
    setUserStats(prev => ({
      ...prev,
      culturalCapital: prev.culturalCapital + totalCulturalCapital,
      totalNFTs: droppedNFT ? prev.totalNFTs + 1 : prev.totalNFTs,
      totalWorshipSessions: prev.totalWorshipSessions + 1,
      level: Math.floor((prev.culturalCapital + totalCulturalCapital) / 100) + 1
    }));

    setShowCompletion(true);
  };

  // ç¥ˆã‚Šåœæ­¢
  const stopPrayer = () => {
    setIsActive(false);
    setIsPrayerActive(false);
    setShowPrayerModal(false);
    setTimeRemaining(0);

    if (meditationTimerRef.current) {
      clearInterval(meditationTimerRef.current);
    }
    if (breathingTimerRef.current) {
      clearInterval(breathingTimerRef.current);
    }
  };

  // æ™‚é–“ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  // Google MapsåˆæœŸåŒ–
  useEffect(() => {
    if (!isLoaded) {
      loadGoogleMapsScript();
    }
  }, [isLoaded, loadGoogleMapsScript]);

  useEffect(() => {
    if (isLoaded && mapRef.current) {
      const map = initializeMap(mapRef.current);
      if (map) {
        addMarkers(map, []);
      }
    }
  }, [isLoaded, initializeMap, addMarkers]);

  return (
    <div className="worship">
      <div className="worship-container">
        {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
        <div className="worship-header">
          <div className="header-content">
            <div className="title-section">
              <h1>ğŸ™ ç¥ç¤¾å‚æ‹</h1>
              <p className="subtitle">ç‘æƒ³ã‚’é€šã˜ã¦å¿ƒã‚’æ¸…ã‚ã€ç¥è–ãªNFTã‚’ç²å¾—ã—ã‚ˆã†</p>
            </div>


          </div>
        </div>

        {/* å®Œäº†ç”»é¢ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */}
        {showCompletion && completionRewards && (
          <div className="completion-overlay">
            <div className="completion-modal">
              <div className="completion-header">
                <h2>ğŸ‰ å‚æ‹å®Œäº†ï¼</h2>
                <button 
                  className="close-btn"
                  onClick={() => setShowCompletion(false)}
                >
                  Ã—
                </button>
              </div>

              <div className="completion-content">
                <div className="omikuji-result">
                  <h3>ãŠã¿ãã˜çµæœ</h3>
                  <div className={`omikuji-card ${completionRewards.omikujiResult}`}>
                    {completionRewards.omikujiResult}
                  </div>
                </div>

                <div className="rewards-summary">
                  <h3>ç²å¾—å ±é…¬</h3>
                  <div className="reward-item">
                    <span>æ–‡åŒ–è³‡æœ¬: +{completionRewards.totalCulturalCapital}</span>
                  </div>
                  <div className="reward-item">
                    <span>çµŒé¨“å€¤: +{completionRewards.experience}</span>
                  </div>
                </div>

                {completionRewards.droppedNFT && (
                  <div className="nft-drop">
                    <h3>ğŸ NFTãƒ‰ãƒ­ãƒƒãƒ—ï¼</h3>
                    <div className="dropped-nft">
                      <div 
                        className="nft-icon"
                        style={{ backgroundColor: completionRewards.droppedNFT.color }}
                      >
                        {completionRewards.droppedNFT.emoji}
                      </div>
                      <div className="nft-info">
                        <h4>{completionRewards.droppedNFT.name}</h4>
                        <p className={`rarity ${completionRewards.droppedNFT.rarity}`}>
                          {completionRewards.droppedNFT.rarity}
                        </p>
                        <p className="power">âš¡ {completionRewards.droppedNFT.power}</p>
                      </div>
                    </div>

                    {completionRewards.mintResult && (
                      <div className="mint-success">
                        âœ… ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã«è¨˜éŒ²ã•ã‚Œã¾ã—ãŸï¼
                      </div>
                    )}
                  </div>
                )}

                <button 
                  className="continue-btn"
                  onClick={() => setShowCompletion(false)}
                >
                  ç¶šã‘ã‚‹
                </button>
              </div>
            </div>
          </div>
        )}



        {/* ç¥ˆã‚Šã®ç¨®é¡é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ« */}
        {showPrayerSelectionModal && (
          <div className="duration-modal-overlay">
            <div className="duration-modal prayer-selection">
              <div className="modal-header">
                <h3>ğŸ™ ç¥ˆã‚Šã®ç¨®é¡ã‚’é¸æŠ</h3>
                <button 
                  className="modal-close"
                  onClick={() => setShowPrayerSelectionModal(false)}
                >
                  âœ•
                </button>
              </div>
              <div className="modal-body">
                <div className="prayer-types-grid">
                  {prayerTypes.map(prayerType => (
                    <div
                      key={prayerType.id}
                      className="prayer-type-card"
                      onClick={() => handlePrayerTypeSelect(prayerType)}
                      style={{ borderColor: prayerType.color }}
                    >
                      <div className="prayer-emoji" style={{ color: prayerType.color }}>
                        {prayerType.emoji}
                      </div>
                      <h4>{prayerType.title}</h4>
                      <p className="prayer-description">{prayerType.description}</p>
                      <div className="prayer-duration">
                        â±ï¸ {Math.floor(prayerType.duration / 60)}åˆ†é–“
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
        )}

        {/* ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ç¥ˆã‚Šãƒ¢ãƒ¼ãƒ€ãƒ« */}
        {showPrayerModal && getCurrentPrayerType() && (
          <div className="duration-modal-overlay">
            <div className="duration-modal active-prayer">
              <div className="modal-header">
                <h3>{getCurrentPrayerType()?.title}</h3>
                <button 
                  className="modal-close"
                  onClick={stopPrayer}
                >
                  âœ•
                </button>
              </div>
              <div className="modal-body">
                <div className="active-prayer-content">
                  <div className="prayer-circle-modal" style={{ borderColor: getCurrentPrayerType()?.color }}>
                    <div className="prayer-emoji-large" style={{ color: getCurrentPrayerType()?.color }}>
                      {getCurrentPrayerType()?.emoji}
                    </div>
                    <div className="timer-display">
                      {formatTime(timeRemaining)}
                    </div>
                    <div className="breathing-guide-text">
                      {breathingPhase === 'inhale' && 'æ¯ã‚’å¸ã£ã¦'}
                      {breathingPhase === 'hold' && 'æ¯ã‚’æ­¢ã‚ã¦'}
                      {breathingPhase === 'exhale' && 'æ¯ã‚’åã„ã¦'}
                    </div>
                  </div>
                  
                  <div className="prayer-message">
                    {getCurrentPrayerType()?.message}
                  </div>

                  <div className="prayer-progress">
                    <div className="progress-bar">
                      <div 
                        className="progress-fill"
                        style={{ 
                          width: `${((selectedDuration - timeRemaining) / selectedDuration) * 100}%`,
                          backgroundColor: getCurrentPrayerType()?.color
                        }}
                      ></div>
                    </div>
                    <p className="time-info">
                      {formatTime(selectedDuration - timeRemaining)} / {formatTime(selectedDuration)}
                    </p>
                  </div>

                  <button 
                    className="stop-prayer-btn"
                    onClick={stopPrayer}
                  >
                    ç¥ˆã‚Šçµ‚äº†
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */}
        {!isActive ? (
          <div className="worship-content">
            {/* ã‚ãªãŸã®ç¥ç¤¾ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */}
            <div className="shrine-section">
              <h2>â›©ï¸ ã‚ãªãŸã®ç¥ç¤¾</h2>
              <div className="shrine-preview">
                <ReadOnlyShrine />
              </div>
            </div>

            {/* å‚æ‹ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */}
            <div className="prayer-section">
              <h2>ğŸ™ å‚æ‹</h2>
              <div className="prayer-panel">
                <p className="prayer-description">
                  å¿ƒã‚’è½ã¡ç€ã‘ã€ç¥è–ãªæ™‚é–“ã‚’éã”ã—ã¾ã—ã‚‡ã†
                </p>

                <button 
                  className="start-prayer-btn"
                  onClick={handlePrayerStart}
                  disabled={!isReady}
                >
                  {isReady ? 'ğŸ™ ç¥ˆã‚Šã‚’æ§ã’ã‚‹' : 'â³ æº–å‚™ä¸­...'}
                </button>

                {/* çµ±è¨ˆè¡¨ç¤º */}
                <div className="stats-panel">
                  <h4>å‚æ‹è¨˜éŒ²</h4>
                  <div className="stats-grid">
                    <div className="stat-item">
                      <span className="stat-value">{userStats.culturalCapital}</span>
                      <span className="stat-label">æ–‡åŒ–è³‡æœ¬</span>
                    </div>
                    <div className="stat-item">
                      <span className="stat-value">{userStats.totalNFTs}</span>
                      <span className="stat-label">NFTæ•°</span>
                    </div>
                    <div className="stat-item">
                      <span className="stat-value">{userStats.meditationStreak}</span>
                      <span className="stat-label">é€£ç¶šæ—¥æ•°</span>
                    </div>
                    <div className="stat-item">
                      <span className="stat-value">{userStats.level}</span>
                      <span className="stat-label">ãƒ¬ãƒ™ãƒ«</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        ) : (
          <div className="prayer-active">
            {/* å¹»æƒ³çš„ãªãƒã‚¤ç¥ç¤¾è¡¨ç¤ºï¼ˆèª­ã¿å–ã‚Šå°‚ç”¨ï¼‰ */}
            <div className="mystical-shrine-overlay">
              <ReadOnlyShrine />
            </div>

            {/* ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ç¥ˆã‚Šç”»é¢ */}
            <div className="prayer-circle">
              <div className={`breathing-guide ${breathingPhase}`}>
                <div className="timer-display">
                  {formatTime(timeRemaining)}
                </div>
                <div className="prayer-instruction">
                  {breathingPhase === 'inhale' && 'å¿ƒã‚’æ¸…ã‚ã¦'}
                  {breathingPhase === 'hold' && 'æ„Ÿè¬ã‚’è¾¼ã‚ã¦'}
                  {breathingPhase === 'exhale' && 'ç¥ˆã‚Šã‚’æ§ã’ã¦'}
                </div>
                <div className="breathing-count">{breathingTimer}</div>
              </div>
            </div>

            <div className="meditation-controls">
              <button className="stop-btn" onClick={stopPrayer}>
                ç¥ˆã‚Šçµ‚äº†
              </button>
            </div>

            <div className="session-info">
              <div className="current-session">
                <span>ğŸµ {selectedSound === 'bell' ? 'éˆ´ã®éŸ³' : 
                       selectedSound === 'nature' ? 'æ£®ã®éŸ³' : 
                       selectedSound === 'water' ? 'å·ã®ã›ã›ã‚‰ã' : 'é™å¯‚'}</span>
                <span>â±ï¸ {formatTime(selectedDuration - timeRemaining)} / {formatTime(selectedDuration)}</span>
              </div>
            </div>
          </div>
        )}

        {/* ç¥ç¤¾ãƒãƒƒãƒ—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */}
        <div className="shrine-map-section">
          <h3>ğŸ—¾ è¿‘ãã®ç¥ç¤¾ã‚’æ¢ã™</h3>
          <div className="map-container">
            {error ? (
              <div className="map-error">
                ãƒãƒƒãƒ—ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: {error}
              </div>
            ) : !isLoaded ? (
              <div className="loading-overlay">
                <div className="loading-spinner">
                  <div className="spinner"></div>
                  <p>ãƒãƒƒãƒ—ã‚’èª­ã¿è¾¼ã¿ä¸­...</p>
                </div>
              </div>
            ) : (
              <div ref={mapRef} className="google-map"></div>
            )}
          </div>
        </div>


      </div>
    </div>
  );
};

export default Worship;